	; Prelude for:
	; 1: 1 PROG [prog] type: ()=>void
	processor 6502 ; TEH BEAST
	ORG $0801 ; BASIC STARTS HERE
	HEX 0C 08 0A 00 9E 20 32 30 36 34 00 00 00
	ORG $0810 ; MY PROGRAM STARTS HERE
	; INIT HEAP
	LDA #<HEAPSTART
	STA HEAPTOP
	LDA #>HEAPSTART
	STA HEAPTOP+1
	JSR INITSTACK
	; no child generation for 'struct'
	; no child generation for 'struct'
	; 1: 1 STRUCT struct type: (symbol,record)=>void
	; no child generation for 'new'
	; Prelude for:
	; 7: 16 RECORD [label POINT 1 x 1 y 2] type: ()=>void
	; reserve 8 on the stack for: label (string offset 0), x (number offset 4), y (number offset 6)
	TSX
	TXA
	SEC
	SBC #8
	TAX
	TXS
	; 8:10 STRING "POINT 1"
	LDA #0
	STA STACKACCESS+1
	LDA #7
	STA STACKACCESS
	JSR PUSH16
	LDA #>str0
	STA STACKACCESS+1
	LDA #<str0
	STA STACKACCESS
	; JSR PUSH16
	; 8: 3 LIT_WORD label type: (string)=>void
	; JSR POP16
	TSX
	TXA
	CLC
	ADC #1
	TAX
	LDA STACKACCESS
	STA $0102,X
	LDA STACKACCESS + 1
	STA $0103,X
	TXA
	PHA
	JSR POP16
	PLA
	TAX
	LDA STACKACCESS
	STA $0100,X
	LDA STACKACCESS + 1
	STA $0101,X
	; 9:6 NUMBER 1
	LDA #0
	STA STACKACCESS+1
	LDA #1
	STA STACKACCESS
	; JSR PUSH16
	; 9: 3 LIT_WORD x type: (number)=>void
	; JSR POP16
	TSX
	TXA
	CLC
	ADC #5
	TAX
	LDA STACKACCESS
	STA $0100,X
	LDA STACKACCESS + 1
	STA $0101,X
	; 10:6 NUMBER 2
	LDA #0
	STA STACKACCESS+1
	LDA #2
	STA STACKACCESS
	; JSR PUSH16
	; 10: 3 LIT_WORD y type: (number)=>void
	; JSR POP16
	TSX
	TXA
	CLC
	ADC #7
	TAX
	LDA STACKACCESS
	STA $0100,X
	LDA STACKACCESS + 1
	STA $0101,X
	; 7: 16 RECORD [label POINT 1 x 1 y 2] type: ()=>void
	; push the heap
SAVE_HEAP_7:
	LDA HEAPTOP
	STA STACKACCESS
	STA TOADD+1
	LDA HEAPTOP+1
	STA STACKACCESS+1
	STA TOADD+2
	JSR PUSH16
	; copy mem
	TSX
	INX
	STX FROMADD+1
	LDA #01
	STA FROMADD+2
	LDY #8
	JSR COPYMEM
	CLC
	LDA HEAPTOP
	ADC #<8
	STA HEAPTOP
	LDA HEAPTOP+1
	ADC #0
	STA HEAPTOP+1
	; release 8 on the stack
	TSX
	TXA
	CLC
	ADC #8
	TAX
	TXS
	; 7: 6 NEW new type: (symbol,record)=>Point
	; do heap malloc for size of structure and return back the address
	; 7: 1 LIT_WORD pt1 type: (Point)=>void
	JSR POP16
	LDA STACKACCESS
	STA V_pt1
	LDA STACKACCESS + 1
	STA V_pt1 + 1
	; no child generation for 'struct'
	; no child generation for 'struct'
	; 13: 1 STRUCT struct type: (symbol,record)=>void
	; 18: 7 WORD pt1 type: ()=>Point
	LDA V_pt1
	STA STACKACCESS
	LDA V_pt1 + 1
	STA STACKACCESS + 1
	; JSR PUSH16
	; 18: 1 PRINT print type: (Point)=>void
	; JSR POP16
	JSR PUSH16
PRINT_COMPONENT_STRING_12:
	LDA STACKACCESS
	STA AUX
	LDA STACKACCESS+1
	STA AUX+1
	LDY #0
	LDA (AUX),Y
	STA STACKACCESS
	INY
	LDA (AUX),Y
	STA STACKACCESS+1
	JSR PUSH16
	INY
	LDA (AUX),Y
	STA STACKACCESS
	INY
	LDA (AUX),Y
	STA STACKACCESS+1
	JSR PUSH16
	JSR PRINT_STRING
	LDA #13
	JSR $FFD2
	JSR POP16
	CLC
	LDA STACKACCESS
	ADC #4
	STA STACKACCESS
	LDA STACKACCESS+1
	ADC #0
	STA STACKACCESS+1
	JSR PUSH16
	LDA STACKACCESS
	STA AUX
	LDA STACKACCESS+1
	STA AUX+1
	LDY #0
	LDA (AUX),Y
	STA STACKACCESS
	INY
	LDA (AUX),Y
	STA STACKACCESS+1
	JSR PRINT_INT
	LDA #13
	JSR $FFD2
	JSR POP16
	CLC
	LDA STACKACCESS
	ADC #2
	STA STACKACCESS
	LDA STACKACCESS+1
	ADC #0
	STA STACKACCESS+1
	JSR PUSH16
	LDA STACKACCESS
	STA AUX
	LDA STACKACCESS+1
	STA AUX+1
	LDY #0
	LDA (AUX),Y
	STA STACKACCESS
	INY
	LDA (AUX),Y
	STA STACKACCESS+1
	JSR PRINT_INT
	LDA #13
	JSR $FFD2
	JSR POP16
	; no child generation for 'new'
	; Prelude for:
	; 20: 18 RECORD [x 69 y 240] type: ()=>void
	; reserve 4 on the stack for: x (number offset 0), y (number offset 2)
	TSX
	TXA
	SEC
	SBC #4
	TAX
	TXS
	; 21:6 NUMBER 69
	LDA #0
	STA STACKACCESS+1
	LDA #69
	STA STACKACCESS
	; JSR PUSH16
	; 21: 3 LIT_WORD x type: (number)=>void
	; JSR POP16
	TSX
	TXA
	CLC
	ADC #1
	TAX
	LDA STACKACCESS
	STA $0100,X
	LDA STACKACCESS + 1
	STA $0101,X
	; 22:6 NUMBER 240
	LDA #0
	STA STACKACCESS+1
	LDA #240
	STA STACKACCESS
	; JSR PUSH16
	; 22: 3 LIT_WORD y type: (number)=>void
	; JSR POP16
	TSX
	TXA
	CLC
	ADC #3
	TAX
	LDA STACKACCESS
	STA $0100,X
	LDA STACKACCESS + 1
	STA $0101,X
	; 20: 18 RECORD [x 69 y 240] type: ()=>void
	; push the heap
SAVE_HEAP_17:
	LDA HEAPTOP
	STA STACKACCESS
	STA TOADD+1
	LDA HEAPTOP+1
	STA STACKACCESS+1
	STA TOADD+2
	JSR PUSH16
	; copy mem
	TSX
	INX
	STX FROMADD+1
	LDA #01
	STA FROMADD+2
	LDY #4
	JSR COPYMEM
	CLC
	LDA HEAPTOP
	ADC #<4
	STA HEAPTOP
	LDA HEAPTOP+1
	ADC #0
	STA HEAPTOP+1
	; release 4 on the stack
	TSX
	TXA
	CLC
	ADC #4
	TAX
	TXS
	; 20: 4 NEW new type: (symbol,record)=>Not_point
	; do heap malloc for size of structure and return back the address
	; 20: 1 LIT_WORD a type: (Not_point)=>void
	JSR POP16
	LDA STACKACCESS
	STA V_a
	LDA STACKACCESS + 1
	STA V_a + 1
	; 25:7 STRING "NOT POINT"
	LDA #0
	STA STACKACCESS+1
	LDA #9
	STA STACKACCESS
	JSR PUSH16
	LDA #>str1
	STA STACKACCESS+1
	LDA #<str1
	STA STACKACCESS
	JSR PUSH16
	; 25: 1 PRINT print type: (string)=>void
	JSR PRINT_STRING
	LDA #13
	JSR $FFD2
	; 26: 7 WORD a type: ()=>Not_point
	LDA V_a
	STA STACKACCESS
	LDA V_a + 1
	STA STACKACCESS + 1
	; JSR PUSH16
	; 26: 1 PRINT print type: (Not_point)=>void
	; JSR POP16
	JSR PUSH16
	LDA STACKACCESS
	STA AUX
	LDA STACKACCESS+1
	STA AUX+1
	LDY #0
	LDA (AUX),Y
	STA STACKACCESS
	INY
	LDA (AUX),Y
	STA STACKACCESS+1
	JSR PRINT_INT
	LDA #13
	JSR $FFD2
	JSR POP16
	CLC
	LDA STACKACCESS
	ADC #2
	STA STACKACCESS
	LDA STACKACCESS+1
	ADC #0
	STA STACKACCESS+1
	JSR PUSH16
	LDA STACKACCESS
	STA AUX
	LDA STACKACCESS+1
	STA AUX+1
	LDY #0
	LDA (AUX),Y
	STA STACKACCESS
	INY
	LDA (AUX),Y
	STA STACKACCESS+1
	JSR PRINT_INT
	LDA #13
	JSR $FFD2
	JSR POP16
	; 28:10 NUMBER 2
	LDA #0
	STA STACKACCESS+1
	LDA #2
	STA STACKACCESS
	; JSR PUSH16
	; 28: 1 LIT_WORD scale_x type: (number)=>void
	; JSR POP16
	LDA STACKACCESS
	STA V_scale_x
	LDA STACKACCESS + 1
	STA V_scale_x + 1
	; Prelude for:
	; 29: 12 REF_BLOCK :[xx Number yy Number scale_y 3 new Point [label POINT 2 x xx * scale_x y yy * scale_y]] type: ()=>Point
	JMP AFTER_0
CALL_0:
	; reserve 6 on the stack for: xx (number offset 0), yy (number offset 2), scale_y (number offset 4)
	TSX
	TXA
	SEC
	SBC #6
	TAX
	TXS
	; 29: 29 NUMBER Number type: ()=>number
	; DO NOTHING
	; 29: 25 LIT_WORD yy type: (number)=>void
	JSR POP16
	TSX
	TXA
	CLC
	ADC #3
	TAX
	LDA STACKACCESS
	STA $0100,X
	LDA STACKACCESS + 1
	STA $0101,X
	; 29: 18 NUMBER Number type: ()=>number
	; DO NOTHING
	; 29: 14 LIT_WORD xx type: (number)=>void
	JSR POP16
	TSX
	TXA
	CLC
	ADC #1
	TAX
	LDA STACKACCESS
	STA $0100,X
	LDA STACKACCESS + 1
	STA $0101,X
	; 30:14 NUMBER 3
	LDA #0
	STA STACKACCESS+1
	LDA #3
	STA STACKACCESS
	; JSR PUSH16
	; 30: 5 LIT_WORD scale_y type: (number)=>void
	; JSR POP16
	TSX
	TXA
	CLC
	ADC #5
	TAX
	LDA STACKACCESS
	STA $0100,X
	LDA STACKACCESS + 1
	STA $0101,X
	; no child generation for 'new'
	; Prelude for:
	; 31: 15 RECORD [label POINT 2 x xx * scale_x y yy * scale_y] type: ()=>void
	; reserve 8 on the stack for: label (string offset 0), x (number offset 4), y (number offset 6)
	TSX
	TXA
	SEC
	SBC #8
	TAX
	TXS
	; 32:14 STRING "POINT 2"
	LDA #0
	STA STACKACCESS+1
	LDA #7
	STA STACKACCESS
	JSR PUSH16
	LDA #>str2
	STA STACKACCESS+1
	LDA #<str2
	STA STACKACCESS
	; JSR PUSH16
	; 32: 7 LIT_WORD label type: (string)=>void
	; JSR POP16
	TSX
	TXA
	CLC
	ADC #1
	TAX
	LDA STACKACCESS
	STA $0102,X
	LDA STACKACCESS + 1
	STA $0103,X
	TXA
	PHA
	JSR POP16
	PLA
	TAX
	LDA STACKACCESS
	STA $0100,X
	LDA STACKACCESS + 1
	STA $0101,X
	; 33: 10 WORD xx type: ()=>number
	TSX
	TXA
	CLC
	ADC #9
	TAX
	LDA $0100,X
	STA STACKACCESS
	LDA $0101,X
	STA STACKACCESS + 1
	JSR PUSH16
	; 33: 15 WORD scale_x type: ()=>number
	LDA V_scale_x
	STA STACKACCESS
	LDA V_scale_x + 1
	STA STACKACCESS + 1
	JSR PUSH16
	; 33: 13 MULT * type: (number,number)=>number
	JSR MUL16
	; 33: 7 LIT_WORD x type: (number)=>void
	JSR POP16
	TSX
	TXA
	CLC
	ADC #5
	TAX
	LDA STACKACCESS
	STA $0100,X
	LDA STACKACCESS + 1
	STA $0101,X
	; 34: 10 WORD yy type: ()=>number
	TSX
	TXA
	CLC
	ADC #11
	TAX
	LDA $0100,X
	STA STACKACCESS
	LDA $0101,X
	STA STACKACCESS + 1
	JSR PUSH16
	; 34: 15 WORD scale_y type: ()=>number
	TSX
	TXA
	CLC
	ADC #13
	TAX
	LDA $0100,X
	STA STACKACCESS
	LDA $0101,X
	STA STACKACCESS + 1
	JSR PUSH16
	; 34: 13 MULT * type: (number,number)=>number
	JSR MUL16
	; 34: 7 LIT_WORD y type: (number)=>void
	JSR POP16
	TSX
	TXA
	CLC
	ADC #7
	TAX
	LDA STACKACCESS
	STA $0100,X
	LDA STACKACCESS + 1
	STA $0101,X
	; 31: 15 RECORD [label POINT 2 x xx * scale_x y yy * scale_y] type: ()=>void
	; push the heap
SAVE_HEAP_42:
	LDA HEAPTOP
	STA STACKACCESS
	STA TOADD+1
	LDA HEAPTOP+1
	STA STACKACCESS+1
	STA TOADD+2
	JSR PUSH16
	; copy mem
	TSX
	INX
	STX FROMADD+1
	LDA #01
	STA FROMADD+2
	LDY #8
	JSR COPYMEM
	CLC
	LDA HEAPTOP
	ADC #<8
	STA HEAPTOP
	LDA HEAPTOP+1
	ADC #0
	STA HEAPTOP+1
	; release 8 on the stack
	TSX
	TXA
	CLC
	ADC #8
	TAX
	TXS
	; 31: 5 NEW new type: (symbol,record)=>Point
	; do heap malloc for size of structure and return back the address
	; 29: 12 REF_BLOCK :[xx Number yy Number scale_y 3 new Point [label POINT 2 x xx * scale_x y yy * scale_y]] type: ()=>Point
	; release 6 on the stack
	TSX
	TXA
	CLC
	ADC #6
	TAX
	TXS
	RTS
AFTER_0:
	LDA #<CALL_0
	STA STACKACCESS
	LDA #>CALL_0
	STA STACKACCESS + 1
	; JSR PUSH16
	; 29: 1 LIT_WORD get_point type: (addr)=>void
	; JSR POP16
	LDA STACKACCESS
	STA V_get_point
	LDA STACKACCESS + 1
	STA V_get_point + 1
	; 39:16 NUMBER 1
	LDA #0
	STA STACKACCESS+1
	LDA #1
	STA STACKACCESS
	JSR PUSH16
	; 39:18 NUMBER 2
	LDA #0
	STA STACKACCESS+1
	LDA #2
	STA STACKACCESS
	JSR PUSH16
	; 39: 6 WORD get_point type: ()=>Point
	LDA V_get_point
	STA CALL_FUN_48 + 1
	LDA V_get_point + 1
	STA CALL_FUN_48 + 2
CALL_FUN_48:
	JSR $1111 ; will be overwritten
	; 39: 1 LIT_WORD pt2 type: (Point)=>void
	JSR POP16
	LDA STACKACCESS
	STA V_pt2
	LDA STACKACCESS + 1
	STA V_pt2 + 1
	; 40: 7 WORD pt2 type: ()=>Point
	LDA V_pt2
	STA STACKACCESS
	LDA V_pt2 + 1
	STA STACKACCESS + 1
	; JSR PUSH16
	; 40: 1 PRINT print type: (Point)=>void
	; JSR POP16
	JSR PUSH16
PRINT_COMPONENT_STRING_51:
	LDA STACKACCESS
	STA AUX
	LDA STACKACCESS+1
	STA AUX+1
	LDY #0
	LDA (AUX),Y
	STA STACKACCESS
	INY
	LDA (AUX),Y
	STA STACKACCESS+1
	JSR PUSH16
	INY
	LDA (AUX),Y
	STA STACKACCESS
	INY
	LDA (AUX),Y
	STA STACKACCESS+1
	JSR PUSH16
	JSR PRINT_STRING
	LDA #13
	JSR $FFD2
	JSR POP16
	CLC
	LDA STACKACCESS
	ADC #4
	STA STACKACCESS
	LDA STACKACCESS+1
	ADC #0
	STA STACKACCESS+1
	JSR PUSH16
	LDA STACKACCESS
	STA AUX
	LDA STACKACCESS+1
	STA AUX+1
	LDY #0
	LDA (AUX),Y
	STA STACKACCESS
	INY
	LDA (AUX),Y
	STA STACKACCESS+1
	JSR PRINT_INT
	LDA #13
	JSR $FFD2
	JSR POP16
	CLC
	LDA STACKACCESS
	ADC #2
	STA STACKACCESS
	LDA STACKACCESS+1
	ADC #0
	STA STACKACCESS+1
	JSR PUSH16
	LDA STACKACCESS
	STA AUX
	LDA STACKACCESS+1
	STA AUX+1
	LDY #0
	LDA (AUX),Y
	STA STACKACCESS
	INY
	LDA (AUX),Y
	STA STACKACCESS+1
	JSR PRINT_INT
	LDA #13
	JSR $FFD2
	JSR POP16
	; Prelude for:
	; 42: 14 REF_BLOCK :[p Point print POINT IS: print p] type: ()=>void
	JMP AFTER_1
CALL_1:
	; reserve 2 on the stack for: p (Point offset 0)
	TSX
	TXA
	SEC
	SBC #2
	TAX
	TXS
	; 42: 19 WORD Point type: ()=>Point
	; no asm for constructor
	; 42: 16 LIT_WORD p type: (Point)=>void
	JSR POP16
	TSX
	TXA
	CLC
	ADC #1
	TAX
	LDA STACKACCESS
	STA $0100,X
	LDA STACKACCESS + 1
	STA $0101,X
	; 43:9 STRING "POINT IS:"
	LDA #0
	STA STACKACCESS+1
	LDA #9
	STA STACKACCESS
	JSR PUSH16
	LDA #>str3
	STA STACKACCESS+1
	LDA #<str3
	STA STACKACCESS
	JSR PUSH16
	; 43: 3 PRINT print type: (string)=>void
	JSR PRINT_STRING
	LDA #13
	JSR $FFD2
	; 44: 9 WORD p type: ()=>Point
	TSX
	TXA
	CLC
	ADC #1
	TAX
	LDA $0100,X
	STA STACKACCESS
	LDA $0101,X
	STA STACKACCESS + 1
	; JSR PUSH16
	; 44: 3 PRINT print type: (Point)=>void
	; JSR POP16
	JSR PUSH16
PRINT_COMPONENT_STRING_57:
	LDA STACKACCESS
	STA AUX
	LDA STACKACCESS+1
	STA AUX+1
	LDY #0
	LDA (AUX),Y
	STA STACKACCESS
	INY
	LDA (AUX),Y
	STA STACKACCESS+1
	JSR PUSH16
	INY
	LDA (AUX),Y
	STA STACKACCESS
	INY
	LDA (AUX),Y
	STA STACKACCESS+1
	JSR PUSH16
	JSR PRINT_STRING
	LDA #13
	JSR $FFD2
	JSR POP16
	CLC
	LDA STACKACCESS
	ADC #4
	STA STACKACCESS
	LDA STACKACCESS+1
	ADC #0
	STA STACKACCESS+1
	JSR PUSH16
	LDA STACKACCESS
	STA AUX
	LDA STACKACCESS+1
	STA AUX+1
	LDY #0
	LDA (AUX),Y
	STA STACKACCESS
	INY
	LDA (AUX),Y
	STA STACKACCESS+1
	JSR PRINT_INT
	LDA #13
	JSR $FFD2
	JSR POP16
	CLC
	LDA STACKACCESS
	ADC #2
	STA STACKACCESS
	LDA STACKACCESS+1
	ADC #0
	STA STACKACCESS+1
	JSR PUSH16
	LDA STACKACCESS
	STA AUX
	LDA STACKACCESS+1
	STA AUX+1
	LDY #0
	LDA (AUX),Y
	STA STACKACCESS
	INY
	LDA (AUX),Y
	STA STACKACCESS+1
	JSR PRINT_INT
	LDA #13
	JSR $FFD2
	JSR POP16
	; 42: 14 REF_BLOCK :[p Point print POINT IS: print p] type: ()=>void
	; release 2 on the stack
	TSX
	TXA
	CLC
	ADC #2
	TAX
	TXS
	RTS
AFTER_1:
	LDA #<CALL_1
	STA STACKACCESS
	LDA #>CALL_1
	STA STACKACCESS + 1
	; JSR PUSH16
	; 42: 1 LIT_WORD print_point type: (addr)=>void
	; JSR POP16
	LDA STACKACCESS
	STA V_print_point
	LDA STACKACCESS + 1
	STA V_print_point + 1
	; 47: 13 WORD pt2 type: ()=>Point
	LDA V_pt2
	STA STACKACCESS
	LDA V_pt2 + 1
	STA STACKACCESS + 1
	JSR PUSH16
	; 47: 1 WORD print_point type: ()=>void
	LDA V_print_point
	STA CALL_FUN_61 + 1
	LDA V_print_point + 1
	STA CALL_FUN_61 + 2
CALL_FUN_61:
	JSR $1111 ; will be overwritten
	; 1: 1 PROG [prog] type: ()=>void
	RTS
BCD DS 3 ; USED IN BIN TO BCD
HEAPSAVE DS 3 ; USED IN COPYSTRING
AUXMUL DS 2
HEAPTOP DS 2
TEST_UPPER_BIT: BYTE $80
AUX = $7D
SP16 = $7F
STACKACCESS = $0080
STACKBASE = $0000
COPYMEM:
	TYA
	BEQ ENDCOPY
FROMADD:
	LDA $1111
TOADD:
	STA $1111
	INC FROMADD + 1
	BNE COPY_NO_CARRY1
	INC FROMADD + 2
COPY_NO_CARRY1:
	INC TOADD + 1
	BNE COPY_NO_CARRY2
	INC TOADD + 2
COPY_NO_CARRY2:
	DEY
	BNE COPYMEM
ENDCOPY:
	RTS
PRINT_STRING:
	JSR POP16
	LDX SP16
	LDA STACKBASE + 1,X; LEN
	INX
	INX
	STX SP16
	TAX; NOW IN X WE HAVE THE LEN
	BEQ EXIT_PRINT_STR
	LDY #0
LOOP_PRINT_STRING:
	LDA (STACKACCESS),Y
	JSR $FFD2
	INY
	DEX
	BNE LOOP_PRINT_STRING
EXIT_PRINT_STR:
	RTS
	; stack.a65 from https://github.com/dourish/mitemon/blob/master/stack.a65
INITSTACK:
	LDX #$FF
	STX SP16
	RTS
PUSH16:
	LDX SP16
	LDA STACKACCESS + 1
	STA STACKBASE,X
	DEX
	LDA STACKACCESS
	STA STACKBASE,X
	DEX
	STX SP16
	RTS
POP16:
	LDX SP16
	LDA STACKBASE + 1,X
	STA STACKACCESS
	INX
	LDA STACKBASE + 1,X
	STA STACKACCESS + 1
	INX
	STX SP16
	RTS
DUP16:
	LDX SP16
	LDA STACKBASE + 2,X
	STA STACKBASE,X
	DEX
	LDA STACKBASE + 2,X
	STA STACKBASE,X
	DEX
	STX SP16
	RTS
SWAP16:
	LDX SP16
	LDA STACKBASE + 2,X
	STA STACKBASE,X
	DEX
	LDA STACKBASE + 2,X
	STA STACKBASE,X
	DEX
	LDA STACKBASE + 5,X
	STA STACKBASE + 3,X
	LDA STACKBASE + 6,X
	STA STACKBASE + 4,X
	LDA STACKBASE + 1,X
	STA STACKBASE + 5,X
	LDA STACKBASE + 2,X
	STA STACKBASE + 6,X
	INX
	INX
	STX SP16
	RTS
ADD16:
	LDX SP16
	CLC
	LDA STACKBASE + 1,X;
	ADC STACKBASE + 3,X
	STA STACKBASE + 3,X
	LDA STACKBASE + 2,X
	ADC STACKBASE + 4,X
	STA STACKBASE + 4,X
	INX
	INX
	STX SP16
	RTS
SUB16:
	LDX SP16
	SEC
	LDA STACKBASE + 3,X
	SBC STACKBASE + 1,X
	STA STACKBASE + 3,X
	LDA STACKBASE + 4,X
	SBC STACKBASE + 2,X
	STA STACKBASE + 4,X
	INX
	INX
	STX SP16
	RTS
BINBCD16: SED
	LDA #0
	STA BCD + 0
	STA BCD + 1
	STA BCD + 2
	LDX #16
CNVBIT: ASL STACKACCESS + 0
	ROL STACKACCESS + 1
	LDA BCD + 0
	ADC BCD + 0
	STA BCD + 0
	LDA BCD + 1
	ADC BCD + 1
	STA BCD + 1
	LDA BCD + 2
	ADC BCD + 2
	STA BCD + 2
	DEX
	BNE CNVBIT
	CLD
	RTS
PRINT_INT:
	LDY #0
	JSR BINBCD16
	LDA BCD+2
	AND #$0F
	BEQ DIGIT2
	TAY
	CLC
	ADC #$30
	JSR $FFD2
DIGIT2:
	LDA BCD+1
	LSR
	LSR
	LSR
	LSR
	BNE DO_DIGIT_2
	CPY #00
	BEQ DIGIT_3
DO_DIGIT_2:
	LDY #1
	CLC
	ADC #$30
	JSR $FFD2
DIGIT_3:
	LDA BCD+1
	AND #$0F
	BNE DO_DIGIT_3
	CPY #00
	BEQ DIGIT_4
DO_DIGIT_3:
	LDY #1
	CLC
	ADC #$30
	JSR $FFD2
DIGIT_4:
	LDA BCD+0
	LSR
	LSR
	LSR
	LSR
	BNE DO_DIGIT_4
	CPY #00
	BEQ DIGIT_5
DO_DIGIT_4:
	CLC
	ADC #$30
	JSR $FFD2
DIGIT_5:
	LDA BCD+0
	AND #$0F
	CLC
	ADC #$30
	JSR $FFD2
	RTS
MUL16:
	LDX SP16
	LDA STACKBASE + 3,X    ; Get the multiplicand and
	STA AUXMUL             ; put it in the scratchpad.
	LDA STACKBASE + 4,X
	STA AUXMUL + 1
	PHA
	LDA #0
	STA STACKBASE + 3       ; Zero - out the original multiplicand area
	STA STACKBASE + 4
	PLA
	LDY #$10                ; We'll loop 16 times.
shift_loop:
	ASL STACKBASE + 3,X     ; Shift the entire 32 bits over one bit position.
	ROL STACKBASE + 4,X
	ROL STACKBASE + 1,X
	ROL STACKBASE + 2,X
	BCC skip_add            ; Skip the adding -in to the result if the high bit shifted out was 0
	CLC                     ; Else, add multiplier to intermediate result.
	LDA AUXMUL
	ADC STACKBASE + 3,X
	STA STACKBASE + 3,X
	LDA AUXMUL + 1
	ADC STACKBASE + 4,X
	STA STACKBASE + 4,X
	LDA #0
	ADC STACKBASE + 1,X
	STA STACKBASE + 1,X
skip_add:
	DEY                      ; If we haven't done 16 iterations yet,
	BNE  shift_loop          ; then go around again.
	INX
	INX
	STX SP16
	RTS
	; https://www.ahl27.com/posts/2022/12/SIXTH-div/
DIV16WITHMOD:
;; MAX ITERATIONS IS 16 = 0X10, SINCE WE HAVE 16 BIT NUMBERS
	LDX SP16
	LDY #$10
	;; ADD TWO SPACES ON STACK
	DEX
	DEX
	DEX
	DEX
	LDA #0
	STA STACKBASE + 1,X; REMAINDER
	STA STACKBASE + 2,X
	STA STACKBASE + 3,X; QUOTIENT
	STA STACKBASE + 4,X
	; +5 - 6 IS DENOMINATOR
	; +7 - 8 IS NUMERATOR
	;; SET UP THE NUMERATOR
	LDA #0
	ORA STACKBASE + 8,X
	ORA STACKBASE + 7,X
	BEQ EARLYEXIT
	;; CHECKING IS DENOMINATOR IS ZERO(IF SO WE'LL JUST STORE ZEROS)
	LDA #0
	ORA STACKBASE + 6,X
	ORA STACKBASE + 5,X
	BNE DIVMODLOOP1
EARLYEXIT:
	;; NUMERATOR OR DENOMINATOR ARE ZERO, JUST RETURN
	LDA #0
	STA STACKBASE + 6,X
	STA STACKBASE + 5,X
	INX
	INX
	INX
	INX
	RTS
	;; TRIM DOWN TO LEADING BIT
DIVMODLOOP1:
	LDA STACKBASE + 8,X
	BIT TEST_UPPER_BIT
	BNE END
	CLC
	ASL STACKBASE + 7,X
	ROL STACKBASE + 8,X
	DEY
	JMP DIVMODLOOP1
END:
	;; MAIN DIVISION LOOP
DIVMODLOOP2:
	;; LEFT - SHIFT THE REMAINDER
	CLC
	ASL STACKBASE + 1,X         
	ROL STACKBASE + 2,X
	;; LEFT - SHIFT THE QUOTIENT
	CLC
	ASL STACKBASE + 3,X
	ROL STACKBASE + 4,X
	;; SET LEAST SIGNIFICANT BIT TO BIT I OF NUMERATOR
	CLC
	ASL STACKBASE + 7,X
	ROL STACKBASE + 8,X
	LDA STACKBASE + 1,X
	ADC #0
	STA STACKBASE + 1,X
	LDA STACKBASE + 2,X
	ADC #0
	STA STACKBASE + 2,X
	;; COMPARE REMAINDER TO DENOMINATOR
	; UPPER BYTE(STACKBASE + 2 IS ALREADY IN A)
	CMP STACKBASE + 6,X
	BMI SKIP; IF R < D, SKIP TO NEXT ITERATION 
	BNE SUBTRACT; IF R > D, WE CAN SKIP COMPARING LOWER BYTE
; IF R = D, WE HAVE TO CHECK THE LOWER BYTE
	; LOWER BYTE
	LDA STACKBASE + 1,X
	CMP STACKBASE + 5,X
	BMI SKIP
SUBTRACT:
	;; SUBTRACT DENOMINATOR FROM REMAINDER
	SEC
	; SUBTRACT LOWER BYTE
	LDA STACKBASE + 1,X
	SBC STACKBASE + 5,X
	STA STACKBASE + 1,X
	; SUBTRACT UPPER BYTE
	LDA STACKBASE + 2,X
	SBC STACKBASE + 6,X
	STA STACKBASE + 2,X
	;; ADD ONE TO QUOTIENT
	INC STACKBASE + 3,X
SKIP:
	DEY
	BEQ EXIT
	JMP DIVMODLOOP2
EXIT:  
	;; CLEANUP
	LDA STACKBASE + 1,X
	STA STACKBASE + 5,X
	LDA STACKBASE + 2,X
	STA STACKBASE + 6,X
	LDA STACKBASE + 3,X
	STA STACKBASE + 7,X
	LDA STACKBASE + 4,X
	STA STACKBASE + 8,X
	INX
	INX
	INX
	INX
	RTS
DIV16:
	JSR DIV16WITHMOD
	INX
	INX
	RTS
MOD16:
	JSR DIV16WITHMOD
	LDA STACKBASE + 1,X
	STA STACKBASE + 3,X
	LDA STACKBASE + 2,X
	STA STACKBASE + 4,X
	INX
	INX
	RTS
MALLOC:
	CLC
	ADC HEAPTOP
	STA HEAPTOP
	BCC NOCARRY
	INC HEAPTOP+1
NOCARRY:
	LDA HEAPTOP
	STA STACKACCESS
	LDA HEAPTOP + 1
	STA STACKACCESS + 1
	JSR PUSH16
	RTS
str0: BYTE 80,79,73,78,84,32,49
str1: BYTE 78,79,84,32,80,79,73,78,84
str2: BYTE 80,79,73,78,84,32,50
str3: BYTE 80,79,73,78,84,32,73,83,58
V_Point DS 2
V_pt1 DS 8
V_Not_point DS 2
V_a DS 4
V_scale_x DS 2
V_get_point DS 2
V_pt2 DS 8
V_print_point DS 2
HEAPSTART: